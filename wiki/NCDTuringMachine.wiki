#summary Turing machine in NCD

= Introduction =

The NCD programming language is Turing-complete. The following implementation of a Turing machine in NCD proves this.

= Turing machine =

{{{
process main {
    # Blank symbol.
    var("B") blank;

    # Initial state.
    var("q0") initial_state;

    # State transition rules.
    var([
        {"q0", blank}:{"q1", "1", "right"},
        {"q1", blank}:{"q2", "1", "right"},
        {"q2", blank}:{"q3", "1", "right"},
        {"q3", blank}:{"q4", "2", "stay"},
        {"q4", "2"  }:{"q5", "2", "left"},
        {"q5", "1"  }:{"q6", "2", "left"},
        {"q6", "1"  }:{"q7", "2", "left"},
        {"q7", "1"  }:{"q8", "3", "left"},
        {"q8", blank}:{"q9", "4", "left"}
    ]) rules;

    # Initial tape.
    var({}) initial_tape_left;
    var({}) initial_tape_right;

    # Perform the computation, stopping when no rule matches.
    call("turing", {blank, rules, initial_state, initial_tape_left, initial_tape_right}) results;

    # Print final state.
    to_string(results.tape_left) tape_left;
    to_string(results.tape_right) tape_right;
    to_string({results.side, results.pos}) head_pos;
    to_string(results.state) head_state;
    println("Tape L: ", tape_left);
    println("Tape R: ", tape_right);
    println("Head position: ", head_pos);
    println("Head state: ", head_state);

    exit("0");
}

template turing {
    alias("_arg0") blank;
    value(_arg1) rules;
    alias("_arg2") initial_state;
    alias("_arg3") initial_tape_left;
    alias("_arg4") initial_tape_right;

    # Head state.
    var(initial_state) state;

    # Tape. Positions go like this: ... L2 L1 L0 R0 R1 R2 ... 
    value(initial_tape_left) tape_left;
    value(initial_tape_right) tape_right;

    # Make sure each side of the tape has at least one symbol so we can flip easily.
    tape_left->insert(tape_left.length, blank);
    tape_right->insert(tape_right.length, blank);

    # Head position.
    var("right") side;
    var("0") pos;

    # Enter loop.
    blocker() loop_blk;
    loop_blk->up();
    loop_blk->use();

    # Get symbol under head.
    concat("tape_", side) tape_name;
    alias(tape_name) cur_tape;
    cur_tape->get(pos) symbol;

    # Look for a matching rule.
    rules->try_get({state, symbol}) rule;

    # Branch on whether we found a rule.
    choose({{rule.exists, "turing_have_rule"}}, "<none>") func;
    call(func, {});
}

template turing_have_rule {
    alias("_caller.blank") blank;
    alias("_caller.state") state;
    alias("_caller.side") side;
    alias("_caller.pos") pos;
    alias("_caller.loop_blk") loop_blk;
    alias("_caller.cur_tape") cur_tape;
    alias("_caller.rule") rule;

    # Extract directions from rule.
    rule->get("0") new_state;
    rule->get("1") new_symbol;
    rule->get("2") move;

    # Change head state.
    state->set(new_state);

    # Replace symbol under head.
    cur_tape->remove(pos);
    cur_tape->insert(pos, new_symbol);

    # Branch based on how we move.
    strcmp(move, side) is_outside;
    strcmp(move, "stay") is_stay;
    strcmp(pos, "0") is_zero;
    choose({{is_outside, "turing_move_outside"}, {is_stay, "<none>"}, {is_zero, "turing_move_flip"}}, "turing_move_inside") func;
    call(func, {});

    # Continue loop.
    loop_blk->downup();
}

template turing_move_outside {
    alias("_caller.blank") blank;
    alias("_caller.cur_tape") cur_tape;
    alias("_caller.pos") pos;

    # Increment position.
    num_add(pos, "1") new_pos;
    pos->set(new_pos);

    # If the new position is out of range, extend tape.
    strcmp(pos, cur_tape.length) need_extend;
    choose({{need_extend, "turing_move_outside_extend"}}, "<none>") func;
    call(func, {});
}

template turing_move_outside_extend {
    alias("_caller.blank") blank;
    alias("_caller.cur_tape") cur_tape;
    alias("_caller.pos") pos;

    # Add a blank to the end of the tape.
    cur_tape->insert(pos, blank);
}

template turing_move_flip {
    alias("_caller.side") side;
    alias("_caller.move") move;

    # Flip side, leave pos at zero.
    side->set(move);
}

template turing_move_inside {
    alias("_caller.pos") pos;

    # Decrement position.
    num_subtract(pos, "1") new_pos;
    pos->set(new_pos);
}
}}}

= Example =

The Turing machine included in the example produces the following:

{{{
$ badvpn-ncd --loglevel warning --config-file ./turing.ncd
Tape L: {"4", "B"}
Tape R: {"3", "2", "2", "2"}
Head position: {"left", "1"}
Head state: "q9"
$ 
}}}

Note that the left side of the tape is reversed, both in input and output - the "B" printed above belongs to the far left of the tape.