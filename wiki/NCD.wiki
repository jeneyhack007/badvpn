#summary NCD - powerful and extensible network interface configuration
#labels linux,network,interface,configuration,hotplug,dhcp,flexible,powerful

= Contents =

<wiki:toc max_depth="1" />

= Introduction =

NCD, the Network Configuration Daemon, is a daemon and programming language for configuration of network interfaces and other aspects of the operating system. It implements various functionalities as built-in modules, which may be used from an NCD program wherever and for whatever purpose the user needs them. This modularity makes NCD extremely flexible and extensible. It does a very good job with hotplugging in various forms, like USB network interfaces and link detection for wired devices. New features can be added by implementing statements as C-language modules using a straightforward interface.

NCD is only available for Linux. It is included in the BadVPN software package.

= Why ? =

If you use Linux on a desktop system, you must have heard of a program called !NetworkManager. It is a program that is meant to take care of network configuration on the OS. It is designed to be extremely easy and simple to use; it has a GUI with a wireless network list, easy wireless and IP configuration, support for VPN, etc..

This all seems good. Until you want to use two VPNs at the same time. Or add some nontrivial iptables rules. Or tell it not to mess with the network interface called eth1. Or setup a bridge interface. Basically, it's a hardcoded mess, and if you want it to do something the designers haven't specifically foreseen and implemented, better go crying right away.

Other network configuration frameworks have similar problems. The Gentoo init scripts, for example, can't even do DHCP right (it times out and forgets about the interface forever)!

My conclusion was that, for more powerful and extensible network configuration, the existing systems need to be thrown away; a new system better suited to the needs of power users needs to be designed. So here comes NCD!

= Basics =

NCD is used by writing an NCD program (the "configuration file"), then starting the `badvpn-ncd` program as a daemon (usually at system boot time). NCD will then keep running the supplied program, until it is requested to terminate (usually at shutdown time). NCD is designed to work in the background without any need to communicate with the user, and to automatically recover from any transient problems. The goal is to make things (e.g. network access) "just work", while still allowing dynamic and complex configuration.

= Model of execution =

A NCD program (see example below) consists of a set of so-called *processes*. Globally, the processes can be considered to execute in parallel. Each process consists of a list of *statements*.

When NCD starts up, all statements are *uninitialized*. Then the first statement in every process is *inizialized*. An initialized statement is first in the *down* state. It may at any time transition into the *up* state. When it does so, the next statement in the process is initialized, and when this one transitions up, the next one is initialized, etc..

A statement (A) that is initialized and up can, at any time, go back into the down state. When this happens, NCD will cease initializing statements in the containing process, and will begin *deinitializing* statements, from the *bottom up*, until all statements following statement A are uninitialized; it will then wait for the offending statement A to go back up, and continue initializing statements from that point.

The deinitialization of a statement often has the *reverse effect* of initialization; for example, if a statement added a routing table entry on initialization, it will remove this same routing table entry on deinitialization. This design is very suitable for various configuration tasks, as it avoids possible leaks. This design makes it trivially easy to, for example, make sure than when a network cable is pulled out, the associated routes and IP addresses are removed.

When a statement is initialized, it is provided with a list of *arguments* which tell the underlying module specifically what it is supposed to do. An argument is either a string or a list of strings and lists. Arguments can either be provided literally in the statement specification (strings only), or they may refer to *variables*, whose values are provided by preceding statements in the process. Variables are key to the power of NCD.

When NCD is requested to terminate, it starts deinitializing all processes from the bottom up, like described above, and this deinitialization continues until all statements in all processes are deinitialized. NCD then exits.

The NCD interpreter by itself does not provide any control constructs. These are however implemented as statements which communicate behind the back of the interpreter. An example of this are the `provide()` and `depend()` statements.

= Complete example =

This is an example NCD program that works with two network interfaces, both of which may be used for Internet access. 
When both are working, eth1 has priority for Internet access (e.g. if eth0 is up, but later eth1 also comes up, the configuration will be changed to use eth1 for Internet access).

{{{
process eth0 {
    # Set device.
    var("eth0") dev;

    # Wait for device.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);

    # DHCP configuration.
    # net.ipv4.dhcp() will block here until it obtaines an IP address.
    # It doesn't check the obtained address in any way,
    # so as a basic security measure, do not proceed if it is local.
    net.ipv4.dhcp(dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);
    var(dhcp.addr) addr;
    var(dhcp.prefix) addr_prefix;
    var(dhcp.gateway) gateway;
    var(dhcp.dns_servers) dns_servers;

    # Assign IP address.
    net.ipv4.addr(dev, addr, addr_prefix);

    # Go on configuring the network.
    multiprovide("NET-eth0");
}

process eth1 {
    # Set device.
    var("eth1") dev;

    # Wait for device.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);

    # Static configuration.
    var("192.168.111.116") addr;
    var("24") addr_prefix;
    var("192.168.111.1") gateway;
    list("192.168.111.14", "193.2.1.66") dns_servers;

    # Assign IP address.
    net.ipv4.addr(dev, addr, addr_prefix);

    # Go on configuring the network.
    multiprovide("NET-eth1");
}

process NETCONF {
    # Wait for some network connection. Prefer eth1 by putting it in front of eth0.
    list("NET-eth1", "NET-eth0") pnames;
    multidepend(pnames) ifdep;

    # Alias device values.
    var(ifdep.dev) dev;
    var(ifdep.addr) addr;
    var(ifdep.addr_prefix) addr_prefix;
    var(ifdep.gateway) gateway;
    var(ifdep.dns_servers) dns_servers;

    # Add default route.
    net.ipv4.route("0.0.0.0", "0", gateway, "20", dev);

    # Configure DNS servers.
    net.dns(dns_servers, "20");
}
}}}

= More examples =

For wireless LAN, see [NCD_wireless_example].

There is also an alternative introduction to NCD, and more examples, which include BadVPN interfaces: http://code.google.com/p/badvpn/source/browse/trunk/ncd/README .

= Requirements =

NCD requires various programs during execution. In particular:

  * *iproute2* (`ip` command) is needed by the `net.up`, `net.ipv4.addr` and `net.ipv4.route` modules. Not all distributions come with that; Gentoo for example doesn't.

  * *udev >=143* is needed for `net.backend.waitdevice` and `net.watch_interfaces`.

= Running it =

== Disabling existing network configuration ==

Before you start NCD, you have to stop any existing network configuration system to avoid interference.

  * Gentoo: stop `NetworkManager` init script, stop `net.` init scripts, except `net.lo`.
  * Ubuntu: stop !NetworkManager using `initctl stop network-manager`

Also, !NetworkManager has a habit of not deconfiguring interfaces when stopped. If you had !NetworkManager running:

  * Remove IP addresses: `ip addr del <addr>/<prefix> dev <iface>`
  * Set down: `ip link set <iface> down`

== Testing from command line == 

Once you're sure your interfaces are deconfigured and there is nothing that could interfere, then try the program (`/etc/ncd.conf`) out by running (as root):
{{{
badvpn-ncd --config-file /etc/ncd.conf
}}}

== Automatically ==

If you installed BadVPN via a package manager, NCD is integrated into your distro's init system, to use `/etc/ncd.conf` as the NCD program:

  * Gentoo: Disable `NetworkManager` init script. Delete `net.` init scripts (which are symlinks to `net.lo`), except `net.lo` itself, to prevent Gentoo from autoconfiguring interfaces. Use the `/etc/init.d/badvpn-ncd` init script to start NCD.
  * Arch: Disable any existing network config. Use the `/etc/rc.d/badvpn-ncd` init script to start NCD.
  * Ubuntu: Disable !NetworkManager by editing `/etc/init/network-manager.conf` or uninstalling `network-manager`. Use the `/etc/init/badvpn-ncd.conf` upstart script to start NCD. The script is disabled by default (the "start on" line inside it is commented out). However be aware that `apt-get` will start it regardless when it's installed (the default `/etc/ncd.conf` is a no-op to avoid damage here). You can manually control the service using `initctl <start/stop/restart> badvpn-ncd`.

= Module documentation =

Individual statement types (modules) are described briefly in the headers of their source files, under ncd/modules/ in the BadVPN source code: http://code.google.com/p/badvpn/source/browse/#svn%2Ftrunk%2Fncd%2Fmodules .

= Event handling and imperative style =

NCD has some support for imperative-style event handling via the above-described execution model. In particular:

 * Method calls, which are statements that cooperate with an existing running statement. Method calls can be used to store state into and control the base statement. A trivial example, where a method of the list() statement is used to change its value:

{{{
process foo {
    list("Hello", "World") mylist;
    mylist->append("Of");
    mylist->append("NCD!");
    concatv(mylist) string;
    println(string); # result: HelloWorldOfNCD!
}
}}}

Note that the `append()` statements permanently change `mylist`; the appended values will not be removed when the `append()` statements are deinitialized.

 * Statements which report events by going up and exposing the event via their variables, and go down when their nextevent() method is called, waiting for the next event. For example, a program which prints file change notifications for a directory:

{{{
process foo {
    # Wait for directory event.
    sys.watch_directory("/home/ambro/mydir") dirwarcher;

    # Print the event.
    println(dirwarcher.event_type, " ", dirwarcher.filename);

    # Finish event. dirwarcher goes down and then goes
    # back up on next event.
    dirwarcher->nextevent();
}
}}}

This works for example like that:

{{{
mydir $ touch file1 file2
-- you start NCD --
-- NCD says: added file1
-- NCD says: added file2
mydir $ rm file1
-- NCD says: removed file1
}}}

 * Dynamic process management via process templates. Combined with event reporting modules, this allows having a dynamic set of similar NCD processes, each working with some resource (such as a network device). For instance, here is an NCD program which performs DHCP on every network interface. The important thing to note is that DHCP will be done on any network interface as it is plugged in, without prior knowledge about it.

{{{
process main {
    # Create process manager, which is we use to create new processes from the
    # interface process template, and to stop them.
    process_manager() manager;

    # Wait for network interface event.
    net.watch_interfaces() watcher;

    # Was a network interface added?
    strcmp(watcher.event_type, "added") is_added;

    # Was a network interface removed?
    strcmp(watcher.event_type, "removed") is_removed;

    # Allow handling of "added" and "removed" events.
    provide("interface_event");

    # If neither added nor removed, skip the event here.
    ifnot(is_added);
    ifnot(is_removed);
    watcher->nextevent();
}

process interface_added {
    # Wait for event and proceed only if it's our event.
    depend("interface_event") evdep;
    if(evdep.is_added);

    # Start a new process for this network interface!
    # Give it the network interface name as a single argument.
    # Create the process from the template called "interface_template", below.
    list(evdep.watcher.devname) args;
    evdep.manager->start(evdep.watcher.devname, "interface_template", args);

    # Finish event.
    evdep.watcher->nextevent();
}

process interface_removed {
    # Wait for event and proceed only if it's our event.
    depend("interface_event") evdep;
    if(evdep.is_removed);

    # Stop the process for this interface.
    evdep.manager->stop(evdep.watcher.devname);

    # Finish event.
    evdep.watcher->nextevent();
}

# This is a process template. It does not start by itself.
# Instead, new NCD processes are created from it
# with the start() method of process_manager().
template interface_template {
    # Interface name is first argument.
    var(_arg0) dev;

    # Do not configure the loopback interface with DHCP.
    strcmp(dev, "lo") is_local;
    ifnot(is_local);

    # Wait for interface, do DHCP, configure it... Same stuff as in the first example.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);
    net.ipv4.dhcp(dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);
    net.ipv4.addr(dev, dhcp.addr, dhcp.prefix);
}
}}}

See also [NCD_events_example] for a similar but more complex example which responds to key presses from all input devices.