#summary NCD - powerful and extensible network interface configuration
#labels linux,network,interface,configuration,hotplug,dhcp,flexible,powerful

= Contents =

<wiki:toc max_depth="1" />

= Introduction =

NCD, the Network Configuration Daemon, is a daemon and programming language for configuration of network interfaces and other aspects of the operating system. It implements various functionalities as built-in modules, which may be used from an NCD program wherever and for whatever purpose the user needs them. This modularity makes NCD extremely flexible and extensible. It does a very good job with hotplugging in various forms, like USB network interfaces and link detection for wired devices. New features can be added by implementing statements as C-language modules using a straightforward interface.

NCD is only available for Linux. It is included in the BadVPN software package.

= Why ? =

If you use Linux on a desktop system, you must have heard of a program called !NetworkManager. It is a program that is meant to take care of network configuration on the OS. It is designed to be extremely easy and simple to use; it has a GUI with a wireless network list, easy wireless and IP configuration, support for VPN, etc..

This all seems good. Until you want to use two VPNs at the same time. Or add some nontrivial iptables rules. Or tell it not to mess with the network interface called eth1. Or setup a bridge interface. Basically, it's a hardcoded mess, and if you want it to do something the designers haven't specifically foreseen and implemented, better go crying right away.

Other network configuration frameworks have similar problems. The Gentoo init scripts, for example, can't even do DHCP right (it times out and forgets about the interface forever)!

My conclusion was that, for more powerful and extensible network configuration, the existing systems need to be thrown away; a new system better suited to the needs of power users needs to be designed. So here comes NCD!

= Basics =

NCD is used by writing an NCD program (the "configuration file"), then starting the `badvpn-ncd` program as a daemon (usually at system boot time). NCD will then keep running the supplied program, until it is requested to terminate (usually at shutdown time). NCD is designed to work in the background without any need to communicate with the user, and to automatically recover from any transient problems. The goal is to make things (e.g. network access) "just work", while still allowing dynamic and complex configuration.

= Model of execution =

A NCD program (see example below) consists of a set of so-called *processes*. Globally, the processes can be considered to execute in parallel. Each process consists of a list of *statements*.

When NCD starts up, all statements are *uninitialized*. Then the first statement in every process is *inizialized*. An initialized statement is first in the *down* state. It may at any time transition into the *up* state. When it does so, the next statement in the process is initialized, and when this one transitions up, the next one is initialized, etc..

A statement (A) that is initialized and up can, at any time, go back into the down state. When this happens, NCD will cease initializing statements in the containing process, and will begin *deinitializing* statements, from the *bottom up*, until all statements following statement A are uninitialized; it will then wait for the offending statement A to go back up, and continue initializing statements from that point.

The deinitialization of a statement often has the *reverse effect* of initialization; for example, if a statement added a routing table entry on initialization, it will remove this same routing table entry on deinitialization. This design is very suitable for various configuration tasks, as it avoids possible leaks. This design makes it trivially easy to, for example, make sure than when a network cable is pulled out, the associated routes and IP addresses are removed.

When a statement is initialized, it is provided with a list of *arguments* which tell the underlying module specifically what it is supposed to do. An argument is either a string or a list of strings and lists. Arguments can either be provided literally in the statement specification, or they may refer to *variables*, whose values are provided by preceding statements in the process. Variables are key to the power of NCD.

A statement is specified as `statement(arg1, ..., argN);`. Optionally, it can be given an identifier: `statement(arg1, ..., argN) identifier;`.

A variable is used by passing `object.variable` as an argument. Here, `object` is an identifier of one of the statements in the process, declared somewhere above (later statements with that name shadow the earlier); `variable` is the name of the variable within this statement. Additionally, if only `object` is passed, it refers to the empty string variable within `object` (thus, you're still passing a *value* (string, list), *not* a reference to the statement).

When NCD is requested to terminate, it starts deinitializing all processes from the bottom up, like described above, and this deinitialization continues until all statements in all processes are deinitialized. NCD then exits.

The NCD interpreter by itself does not provide any control constructs. These are however implemented as statements which communicate behind the back of the interpreter. An example of this are the `provide()` and `depend()` statements.

= Complete example =

This is an example NCD program that works with a single wired network interface and uses DHCP to obtain the IP address, default route and DNS servers.

{{{
process lan {
    # Set device.
    var("eth0") dev;

    # Wait for device, set it up, and wait for network cable.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);

    # DHCP configuration.
    # net.ipv4.dhcp() will block here until it obtaines an IP address.
    # Note that it will only obtain the IP address, and *not* assign it;
    # we do that with a separate command below.
    net.ipv4.dhcp(dev) dhcp;

    # Check IP address - make sure it's not local.
    # If you have other reserved subnets around, check for those too.
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);

    # Assign IP address, as obtained by DHCP.
    net.ipv4.addr(dev, dhcp.addr, dhcp.prefix);

    # Add default route, as obtained by DHCP.
    net.ipv4.route("0.0.0.0", "0", dhcp.gateway, "20", dev);

    # Configure DNS servers, as obtained by DHCP.
    net.dns(dhcp.dns_servers, "20");
}
}}}

= More examples =

See [NCD_examples] for more complex examples. NCD is capable of much more than the above program may suggest. For example, it can handle multiple network interfaces with priorities for Internet access, it can work with wireless networks and BadVPN network interfaces.

There is also an alternative introduction to NCD, and more examples, which include BadVPN interfaces: http://code.google.com/p/badvpn/source/browse/trunk/ncd/README .

= Requirements =

NCD requires various programs during execution. In particular:

  * *iproute2* (`ip` command) is needed by the `net.up`, `net.ipv4.addr` and `net.ipv4.route` modules. Not all distributions come with that; Gentoo for example doesn't.

  * *udev >=143* is needed for `net.backend.waitdevice` and `net.watch_interfaces`.

= Running it =

For installation instructions see [Installation].

== Disabling existing network configuration ==

Before you start NCD, you have to stop any existing network configuration system to avoid interference.

  * Gentoo: stop `NetworkManager` init script, stop `net.` init scripts, except `net.lo`.
  * Ubuntu: stop !NetworkManager using `initctl stop network-manager`

Also, !NetworkManager has a habit of not deconfiguring interfaces when stopped. If you had !NetworkManager running:

  * Kill dhclient: `killall dhclient`
  * Remove IP addresses: `ip addr del <addr>/<prefix> dev <iface>`
  * Set down: `ip link set <iface> down`

== Testing from command line == 

Once you're sure your interfaces are deconfigured and there is nothing that could interfere, then try the program (`/etc/ncd.conf`) out by running (as root):
{{{
badvpn-ncd --config-file /etc/ncd.conf
}}}

NCD will print status messages as it executes your program. If it's not working as expected, these can help you with debugging it.

== Automatically ==

If you installed BadVPN via a package manager, NCD is integrated into your distro's init system, to use `/etc/ncd.conf` as the NCD program. To use NCD by default, you will have to permanently disable existing network configurations, and have NCD start on boot instead.

To disable existing network configurations:

  * Gentoo: Disable `NetworkManager` init script. Delete `net.` init scripts (which are symlinks to `net.lo`), except `net.lo` itself, to prevent Gentoo from autoconfiguring interfaces.
  * Ubuntu: Disable !NetworkManager by editing `/etc/init/network-manager.conf`, commenting the two `start on` lines, or by uninstalling the `network-manager` package.

To have NCD start on boot:

  * Gentoo: Enable the `/etc/init.d/badvpn-ncd` init script: `rc-update add badvpn-ncd default`
  * Arch: Enable the `/etc/rc.d/badvpn-ncd` init script by adding it to `DAEMONS` in `/etc/rc.conf`. Make sure it comes after syslog.
  * Ubuntu: Use the `/etc/init/badvpn-ncd.conf` Upstart script. The script is disabled by default; the `start on` line inside it is commented out. Uncomment it to have it start on boot. However be aware that `apt-get` will start it regardless when it installs the `badvpn` package (the default `/etc/ncd.conf` is a no-op to avoid damage here). You can also manually control the service using `initctl <start/stop/restart/status> badvpn-ncd`. 

= Module documentation =

Individual statement types (modules) are described briefly in the headers of their source files, under ncd/modules/ in the BadVPN source code: http://code.google.com/p/badvpn/source/browse/#svn%2Ftrunk%2Fncd%2Fmodules .

= Diagnostic output =

The [http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/print.c println() and rprintln()] statements provide diagnostic output to standard outout. `println()` prints a message on initialization, and `rprintln()` prints a message on deinitialization.

{{{
process foo {
    println("Starting");
    rprintln("Stopped");

    sleep("500", "300"); # sleeps 500ms on init and 300ms on deinit

    println("Up");
    rprintln("Down");
}
}}}

= Dependencies =

The [http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/depend.c provide() and depend()] statements implement dependencies.

Suppose we want to wait for a network device, and have some kind of service that works with it:

{{{
process foo {
    var("eth1") dev;
    net.backend.waitdevice(dev);

    println("X: started on device ", dev);
    rprintln("X: stopped on device ", dev);

    # do something with device...
}
}}}

However, what if, after the device is available, we want to run _two services in parallel_?

{{{
process foo {
    var("eth1") dev;
    net.backend.waitdevice(dev);

    provide("DEVICE");
}

process device_service_x {
    depend("DEVICE") dep;

    println("X: started on device ", dep.dev);
    rprintln("X: stopped on device ", dep.dev);

    # do something with device...
}

process device_service_y {
    depend("DEVICE") dep;

    println("Y: started on device ", dep.dev);
    rprintln("Y: stopped on device ", dep.dev);

    # do something with device...
}
}}}

Note how the service processes access the `dev` variable within process `foo` through the dependency. A `depend()` allows access to any variable as seen from the point of the matched `provide()`.

Because of how the NCD interpreter works, `provide()` should usually be the *last statement* in a process. Otherwise, when something before `provide()` goes down, a latter statement could take some time to deinitialize, and during this time, the depending processes may continue initalizing and may request variables through their `depend()`-s - which will fail, because `provide()` is scheduled for deinitialization and cant't resolve variables.

If you wanted to have some statements after a `provide()`, you should instead make a new process that `depend()`-s on this same `provide()` and put the statements there.

There are however exceptions to this rule. For example, the following code wakes up two parallel processes, but then merges back. It's safe because when process `main` is requested to terminate after it merged back, the two parallel processes have initialized completely and won't resolve any variables.

{{{
process main {
    var("eth1") dev;
    net.backend.waitdevice(dev);

    provide("DEVICE");
    depend("X_DONE");
    depend("Y_DONE");

    println("up");
    rprintln("down");
}

process device_service_x {
    depend("DEVICE") dep;

    println("X: started on device ", dep.dev);
    rprintln("X: stopped on device ", dep.dev);

    sleep("1000", "2000");

    provide("X_DONE");
}

process device_service_y {
    depend("DEVICE") dep;

    println("Y: started on device ", dep.dev);
    rprintln("Y: stopped on device ", dep.dev);

    sleep("2000", "1000");

    provide("Y_DONE");
}

}}}

= Event handling and imperative style =

NCD has some support for imperative-style event handling via the above-described execution model. In particular:

 * Method calls, which are statements that cooperate with an existing running statement. Method calls can be used to store state into and control the base statement. A trivial example, where a method of the list() statement is used to change its value:

{{{
process foo {
    list("Hello", "World") mylist;
    mylist->append("Of");
    mylist->append("NCD!");
    concatv(mylist) string;
    println(string); # result: HelloWorldOfNCD!
}
}}}

Note that the `append()` statements permanently change `mylist`; the appended values will not be removed when the `append()` statements are deinitialized.

 * Statements which report events by going up and exposing the event via their variables, and go down when their nextevent() method is called, waiting for the next event. For example, a program which prints file change notifications for a directory:

{{{
process foo {
    # Wait for directory event.
    sys.watch_directory("/home/ambro/mydir") dirwarcher;

    # Print the event.
    println(dirwarcher.event_type, " ", dirwarcher.filename);

    # Finish event. dirwarcher goes down and then goes
    # back up on next event.
    dirwarcher->nextevent();
}
}}}

This works for example like that:

{{{
mydir $ touch file1 file2
-- you start NCD --
-- NCD says: added file1
-- NCD says: added file2
mydir $ rm file1
-- NCD says: removed file1
}}}

 * Dynamic process management via process templates. Combined with event reporting modules, this allows having a dynamic set of similar NCD processes, each working with some resource (such as a network device). For instance, here is an NCD program which performs DHCP on every network interface. The important thing to note is that DHCP will be done on any network interface as it is plugged in, without prior knowledge about it.

{{{
process main {
    # Create process manager, which is we use to create new processes from the
    # interface process template, and to stop them.
    process_manager() manager;

    # Wait for network interface event.
    net.watch_interfaces() watcher;

    # Was a network interface added?
    strcmp(watcher.event_type, "added") is_added;

    # Was a network interface removed?
    strcmp(watcher.event_type, "removed") is_removed;

    # Allow handling of "added" and "removed" events.
    provide("interface_event");

    # If neither added nor removed, skip the event here.
    ifnot(is_added);
    ifnot(is_removed);
    watcher->nextevent();
}

process interface_added {
    # Wait for event and proceed only if it's our event.
    depend("interface_event") evdep;
    if(evdep.is_added);

    # Start a new process for this network interface!
    # Give it the network interface name as a single argument.
    # Create the process from the template called "interface_template", below.
    list(evdep.watcher.devname) args;
    evdep.manager->start(evdep.watcher.devname, "interface_template", args);

    # Finish event.
    evdep.watcher->nextevent();
}

process interface_removed {
    # Wait for event and proceed only if it's our event.
    depend("interface_event") evdep;
    if(evdep.is_removed);

    # Stop the process for this interface.
    evdep.manager->stop(evdep.watcher.devname);

    # Finish event.
    evdep.watcher->nextevent();
}

# This is a process template. It does not start by itself.
# Instead, new NCD processes are created from it
# with the start() method of process_manager().
template interface_template {
    # Interface name is first argument.
    var(_arg0) dev;

    # Do not configure the loopback interface with DHCP.
    strcmp(dev, "lo") is_local;
    ifnot(is_local);

    # Wait for interface, do DHCP, configure it... Same stuff as in the first example.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);
    net.ipv4.dhcp(dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);
    net.ipv4.addr(dev, dhcp.addr, dhcp.prefix);
}
}}}

See also [NCD_events_example] for a similar but more complex example which responds to key presses from all input devices.

= Branching (simple) =

A simple way to branch is using [http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/depend.c provide() and depend()] statements.

{{{
process test {
   # We will be branching based on the value of 'x' here.
   # If 'x' equals "foo", we go one way, else the other way.
   var("bar") x;

   # Produce a value which is either "true" or "false", indicating
   # which way to branch.
   strcmp(x, "foo") is_foo;

   # Branch ... and wait for the branch to finish.
   provide("branch");
   depend("branch_done") br;

   # Print the message.
   println(br.msg);
}

process test_foo {
   depend("branch") dep;
   if(dep.is_foo);

   var("x was foo!") msg;

   provide("branch_done");
}

process test_other {
   depend("branch") dep;
   ifnot(dep.is_foo);

   var("x was NOT foo!") msg;

   provide("branch_done");
}
}}}

However, this is an *inferior* way to branch, because the dependency identifiers `branch` and `branch_done` have global scope. For this reason, this technique is normally useless from within a template process, where there may be multiple instances of a process template executing in parallel, and their use of constant dependency indentifiers will interfere. A proper way to branch is using the `call()` statement (read on).

= Calling templates =

One use of process templates is with `process_manager()`, described above. However, there are other statements which use process templates. Of particular importance is the [http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/call.c call()] statement. The effect of `call()` is mostly equivalent to embedding the body of the called process template into the place of `call()`, including correct reverse execution.

{{{
process foo {
    println("Saying hello...");
    call("say_hello", {});
    println("Successfully said hello!");
}

template say_hello {
    println("Hello!");
    rprintln("Goodbye..."); # like println(), but prints on deinitialization
}
}}}

Additionally, with `call()`, you can:
  * Pass arguments to the template process. However, these can only be values (strings, lists), not actual objects, i.e. you can't call a method on an argument.
  * Access caller's objects from within the called template process via `_caller`. This can be used if you need to "pass objects", and can be made to look like it using `alias()` (see below).
  * Once the called template process has initialized, access its objects through the name of the `call()` statement.

The following example demonstrates these features.

{{{
process foo {
    var("Hello") x;
    call("make_msg", {"Good", "World"}) c;
    println(c.msg); # Prints: HelloGoodWorld
}

template make_msg {
    concat(_caller.x, _arg0, _arg1) msg;
}
}}}

= Branching (correct) =

The `call()` statement can (and should) be used for branching. This works by building the name of the called template dynamically based on runtime values. The following program demonstrates this.

{{{
process test {
   # We will be branching based on the value of 'x' here.
   # If 'x' equals "foo", we go one way, else the other way.
   var("bar") x;

   # Produce a value which is either "true" or "false", indicating
   # which way to branch.
   strcmp(x, "foo") is_foo;

   # Build template name based on the value of is_foo.
   concat("branch_foo_", is_foo) branch_template;

   # Branch.
   call(branch_template, {}) c;

   # Print the message.
   println(c.msg);
}

template branch_foo_true {
    var("x was foo!") msg;
}

template branch_foo_false {
    var("x was NOT foo!") msg;
}
}}}

Compared to simple branching using `provide()` and `depend()`, this branching mechanism is safe to use from template processes.

= Multi-way branching =

The [http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/choose.c choose()] statement together with `call()` can provide "if, else if, ..., else" style branching.

{{{
process foo {
    var("false") is_x;
    var("true") is_y;
    var("false") is_z;

    # If is_x then do_x, else if is_y then do_y, else if is_z then do_z, else do_other.
    choose({{is_x, "do_x"}, {is_y, "do_y"}, {is_z, "do_z"}}, "do_other") func;
    call(func, {});
}

template do_x {
    println("Doing x");
}

template do_y {
    println("Doing y");
}

template do_z {
    println("Doing z");
}

template do_other {
    println("Doing other");
}
}}}

= One-way branching =

It is possible to do a one-way branch by giving `call()` `"<none>"` as the template name to make it do nothing, possibly using `choose()`:

{{{
process foo {
    var("false") is_x;

    # If is_x, then call do_x, else do nothing.
    choose({{is_x, "do_x"}}, "<none>") func;
    call(func, {});
}

template do_x {
    println("Doing x");
}
}}}

= Aliases =

The [http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/alias.c alias()] statement allows a group of variables and objects to be referred to using a new name. It also forwards method calls.

{{{
process foo {
    list("hello", "world") x;
    alias("x") y;
    concatv(y) msg;
    println(msg, y.length); # Prints: helloworld2
    y->shift(); # actually calls x->shift();
    concatv(y) msg;
    println(msg, y.length); # Prints: world1
}
}}}

Additionally, `alias()` can be used to simulate passing actual objects through a `call()` (compared to values), such that the called process can invoke the object's methods:

{{{
process foo {
    process_manager() manager;
    call("start_baz_process", {"_caller.manager", "first_baz"});
}

template start_baz_process {
    alias(_arg0) manager;
    var(_arg1) name;

    manager->start(name, "baz", {name});
}

template baz {
    var(_arg0) name;

    println("baz(", name, "): starting");
    rprintln("baz(", name, "): stopped");
}
}}}

= Foreach =

[http://code.google.com/p/badvpn/source/browse/trunk/ncd/modules/foreach.c foreach()] does something for each element of a list. It is mostly equivalent to putting multiple `call()` statements one after another, but it allows the elements to by dynamic.

{{{
process foo {
    var("World") world;
    foreach({"A", "B", "C"}, "foreach_func", {"Hello", "Goodbye"});
}

template foreach_func {
    var(_arg0) hello;
    var(_arg1) goodbye;

    println(_elem, ": ", hello, _caller.world);
    rprintln(_elem, ": ", goodbye, _caller.world);
}
}}}

The template process called by `foreach()` for every element of the list can access its element using `_elem`. Additionally, like `call()`, it can access arguments passed to `foreach()`, and any variable or object `X` as seen from the point of `foreach()` via `_caller.X`.

The template processes are managed by `foreach()` in the same way as the NCD interpreter initializes and deinitializes statements within a process. In particular, if a statement in one of the template processes goes down, `foreach()` will pause this process, deinitialize any following processes from the bottom up, and only then continue the process where a statement went down (assuming no prior statements went down).

This means that you can use `foreach()` to acquire a set of resources at once. For example, to wait for to all network interfaces on a list to appear:

{{{
process foo {
    list("eth0", "eth1") ifaces;
    foreach(ifaces, "wait_link", {});

    println("all devices exits");
    rprintln("all devices no longer exist (or terminating)");

    # Configure those interfaces all at once here.
}

template wait_device {
    net.backend.waitdevice(_elem);
}
}}}

However, this approach only makes sense if the configuration cannot be applied without all the resources being present at once. If part of the configuration of a single resource can be done independently from other resources, it may make more sense to not directly attempt to acquire it from `foreach()`, but instead start a process using `process_manager()` that deals with this resource. Any configuration that depends on several resources at once can then be done using dependencies.

For example, it makes sense to put a wired interface up immediately when it appears, regardless of the presence of other interfaces. To ease understanding, first a program is presented for a static set of interfaces, and then the dynamic version that takes a list of interfaces. The actual configuration commands are commented out to ease experimentation without changing anything.

{{{
process main {
    # Let interface processes proceed (in case something else was above here).
    provide("START-IFACES");

    # Wait for all interfaces processes to initialize.
    depend("IFACE-eth0");
    depend("IFACE-eth1");

    # All interfaces are available and configured by their processes.
    # Configure something that needs all of them...
    println("wait: up");
    rprintln("wait: down");
}

process interface_eth0 {
    depend("START-IFACES");

    var("eth0") dev;

    # Wait for interface to appear, possibly do more configuration here.
    net.backend.waitdevice(dev);
    #net.up(dev);
    #net.backend.waitlink(dev);

    concat("IFACE-", dev) pname;
    provide(pname);
}

process interface_eth1 {
    depend("START-IFACES");

    var("eth1") dev;

    # Wait for interface to appear, possibly do more configuration here.
    net.backend.waitdevice(dev);
    #net.up(dev);
    #net.backend.waitlink(dev);

    concat("IFACE-", dev) pname;
    provide(pname);
}

}}}

And now the dynamic version, utilizing `foreach()` and `process_manager()`:

{{{
process main {
    list("eth0", "eth1") ifaces;

    # Start "interface" process for each interface.
    process_manager() start_manager;
    foreach(ifaces, "start_interface", {"_caller.start_manager"});

    # Wait for all interface processes to initialize completely.
    process_manager() wait_manager;
    foreach(ifaces, "wait_interface", {});

    # All interfaces are available and configured by their
    # "interface" processes. Configure something that needs all of them...
    println("wait: up");
    rprintln("wait: down");
}

template start_interface {
    var(_elem) dev;
    alias(_arg0) start_manager;

    # Start "interface" process for this interface.
    start_manager->start(dev, "interface", {dev});
}

template interface {
    var(_arg0) dev;

    # Wait for interface to appear, possibly do more configuration here
    # (e.g. set up, wait for link, do DHCP)
    net.backend.waitdevice(dev);
    #net.up(dev);
    #net.backend.waitlink(dev);

    # Signal completion,
    concat("IFACE-", dev) pname;
    provide(pname);
}

template wait_interface {
    var(_elem) dev;

    # Wait for this interface.
    concat("IFACE-", dev) pname;
    depend(pname);
}
}}}