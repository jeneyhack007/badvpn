#summary NCD - examples

= Contents =

<wiki:toc max_depth="1" />

= Introduction =

NCD, the Network Configuration Daemon, is a daemon and programming language for configuration of network interfaces and other aspects of the operating system.

This page provides some network configuration examples using NCD. For a guide to NCD and its basic feaures, see [NCD].

= Multiple connections with priorities =

This is an example NCD program that works with two network interfaces, both of which may be used for Internet access. 
When both are working, eth1 has priority for Internet access (e.g. if eth0 is up, but later eth1 also comes up, the configuration will be changed to use eth1 for Internet access).

{{{
process eth0 {
    # Set device.
    var("eth0") dev;

    # Wait for device.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);

    # DHCP configuration.
    # net.ipv4.dhcp() will block here until it obtaines an IP address.
    # It doesn't check the obtained address in any way,
    # so as a basic security measure, do not proceed if it is local.
    net.ipv4.dhcp(dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);
    var(dhcp.addr) addr;
    var(dhcp.prefix) addr_prefix;
    var(dhcp.gateway) gateway;
    var(dhcp.dns_servers) dns_servers;

    # Assign IP address.
    net.ipv4.addr(dev, addr, addr_prefix);

    # Go on configuring the network.
    multiprovide("NET-eth0");
}

process eth1 {
    # Set device.
    var("eth1") dev;

    # Wait for device.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);

    # Static configuration.
    var("192.168.111.116") addr;
    var("24") addr_prefix;
    var("192.168.111.1") gateway;
    list("192.168.111.14", "193.2.1.66") dns_servers;

    # Assign IP address.
    net.ipv4.addr(dev, addr, addr_prefix);

    # Go on configuring the network.
    multiprovide("NET-eth1");
}

process NETCONF {
    # Wait for some network connection. Prefer eth1 by putting it in front of eth0.
    list("NET-eth1", "NET-eth0") pnames;
    multidepend(pnames) ifdep;

    # Alias device values.
    var(ifdep.dev) dev;
    var(ifdep.addr) addr;
    var(ifdep.addr_prefix) addr_prefix;
    var(ifdep.gateway) gateway;
    var(ifdep.dns_servers) dns_servers;

    # Add default route.
    net.ipv4.route("0.0.0.0", "0", gateway, "20", dev);

    # Configure DNS servers.
    net.dns(dns_servers, "20");
}
}}}

= Wireless, simple =

Create a `wpa_supplicant` configuration file, `/etc/wpa_supplicant/all.conf` for example:

{{{
network={
        ssid="Some Network"
        scan_ssid=1
        key_mgmt=WPA-PSK
        psk="password"
}

network={
        ssid="Other Network"
        scan_ssid=1
        key_mgmt=WPA-PSK
        psk="password"
}
}}}

And use this NCD program:

{{{
process wlan {
    # Set device.
    var("wlan0") dev;

    # Wait for device and rfkill.
    net.backend.waitdevice(dev);
    net.backend.rfkill("wlan", dev);

    # Connect to wireless network.
    # NOTE: you may need /sbin/wpa_supplicant instead of /usr/sbin/wpa_supplicant (Ubuntu for example)!
    list() args;
    net.backend.wpa_supplicant(dev, "/etc/wpa_supplicant/all.conf", "/usr/sbin/wpa_supplicant", args);

    # DHCP configuration.
    net.ipv4.dhcp(dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);
    var(dhcp.addr) addr;
    var(dhcp.prefix) addr_prefix;
    var(dhcp.gateway) gateway;
    var(dhcp.dns_servers) dns_servers;

    # Assign IP address to interface.
    net.ipv4.addr(dev, addr, addr_prefix);

    # Add default route.
    net.ipv4.route("0.0.0.0", "0", gateway, "20", dev);

    # Add DNS servers.
    net.dns(dns_servers, "20");
}
}}}

= Wireless, network-specific IP configuration =

This program uses different IP configurations for different wireless networks. For two known networks a static IP address is used, and for others, DHCP is used. It also plays a sound when connection is established or lost.

{{{
process wlan {
    # Set device.
    var("wlan0") dev;

    # Wait for device and rfkill.
    net.backend.waitdevice(dev);
    net.backend.rfkill("wlan", dev);

    # Connect to wireless network.
    # NOTE: you may need /sbin/wpa_supplicant instead of /usr/sbin/wpa_supplicant (Ubuntu for example)!
    list() args;
    net.backend.wpa_supplicant(dev, "/etc/wpa_supplicant/all.conf", "/usr/sbin/wpa_supplicant", args) sup;

    # wpa_supplicant exposes the 'bssid' and 'ssid' variables.
    println("Connected to wireless network: bssid=", sup.bssid, " ssid=", sup.ssid);

    # Choose configuration.
    # These have to be exclusive, or we activate multiple configurations at once...
    strcmp(sup.ssid, "Some Network") is_home1;
    strcmp(sup.ssid, "Other Network") is_home2;

    # Configure interface.
    provide("WLAN_CONFIG");
    depend("WLAN_CONFIG_DONE") config;

    # Print configuration name.
    println("Using wireless configuration: ", config.config_name);

    # Assign IP address to interface.
    net.ipv4.addr(dev, config.addr, config.addr_prefix);

    # Add default route.
    net.ipv4.route("0.0.0.0", "0", config.gateway, "20", dev);

    # Add DNS servers.
    net.dns(config.dns_servers, "20");

    # Play a sound when connection is established and when it is lost.
    list("/usr/bin/ffplay", "-nodisp", "-autoexit", "/usr/share/sounds/freedesktop/stereo/network-connectivity-established.oga") do;
    list("/usr/bin/ffplay", "-nodisp", "-autoexit", "/usr/share/sounds/freedesktop/stereo/network-connectivity-lost.oga") undo;
    run(do, undo);
}

process wlan_home1 {
    depend("WLAN_CONFIG") wdep;
    if(wdep.is_home1);

    var("Home 1") config_name;

    # Static configuration.
    var("192.168.8.96") addr;
    var("24") addr_prefix;
    var("192.168.8.1") gateway;
    list("192.168.8.1") dns_servers;

    provide("WLAN_CONFIG_DONE");
}

process wlan_home2 {
    depend("WLAN_CONFIG") wdep;
    if(wdep.is_home2);

    var("Home 2") config_name;

    # Static configuration.
    var("192.168.6.57") addr;
    var("24") addr_prefix;
    var("192.168.6.1") gateway;
    list("192.168.6.1") dns_servers;

    provide("WLAN_CONFIG_DONE");
}

process wlan_default {
    depend("WLAN_CONFIG") wdep;
    ifnot(wdep.is_home1);
    ifnot(wdep.is_home2);

    var("Default") config_name;

    # DHCP configuration.
    net.ipv4.dhcp(wdep.dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);
    var(dhcp.addr) addr;
    var(dhcp.prefix) addr_prefix;
    var(dhcp.gateway) gateway;
    var(dhcp.dns_servers) dns_servers;

    provide("WLAN_CONFIG_DONE");
}
}}}

= BadVPN network interface =

A VPN network interface depends on the availability of a network connection. We do a simple wired+DHCP here, as in [NCD]. However anything could be used instead, provided that `provide("NET");` is executed when network connection is available.

{{{
process lan {
    # Set device.
    var("eth0") dev;

    # Wait for device, set it up, and wait for network cable.
    net.backend.waitdevice(dev);
    net.up(dev);
    net.backend.waitlink(dev);

    # DHCP configuration.
    net.ipv4.dhcp(dev) dhcp;
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);

    # Alias IP configuration variables, to allow easy access
    # from the VPN process.
    var(dhcp.addr) addr;
    var(dhcp.prefix) addr_prefix;
    var(dhcp.gateway) gateway;
    var(dhcp.dns_servers) dns_servers;

    # Assign IP address.
    net.ipv4.addr(dev, addr, addr_prefix);

    # Add default route.
    net.ipv4.route("0.0.0.0", "0", gateway, "20", dev);

    # Configure DNS servers.
    net.dns(dns_servers, "20");

    # Go on configuring the VPN.
    # The "NET" is just an identifier for the dependency; it can
    # be any string as long as it's the same in the depend() a few
    # lines below.
    provide("NET");
}

process vpn {
    # Wait for network connection.
    depend("NET") netdep;

    # Choose TAP device name for the VPN.
    var("tap5") dev;

    # Choose bind port for the VPN.
    var("7716") bind_port;

    # Build bind address "0.0.0.0:<bind_port>".
    concat("0.0.0.0:", bind_port) bind_addr;

    # Build local address, "<local_ip>:<bind_port>".
    # We access the "addr" variable in "process lan" through the depend.
    concat(netdep.addr, ":", bind_port) local_ext_addr;

    # Set command line arguments to badvpn-client; --tapdev is provided automatically.
    list(
        "--logger", "syslog", "--syslog-ident", "badvpn-client",
        "--server-name", "<server_name>",
        "--server-addr", "<server-addr>:<port>",
        "--ssl", "--nssdb", "sql:/home/badvpn/nssdb", "--client-cert-name", "peer-<someone>",
        "--transport-mode", "udp", "--encryption-mode", "blowfish", "--hash-mode", "md5", "--otp", "blowfish", "3000", "2000",
        "--scope", "mylanscope", "--scope", "internet",
        "--bind-addr", bind_addr, "--num-ports", "20",
        "--ext-addr", local_ext_addr, "mylanscope"
    ) args;

    # Start badvpn-client. Second argument is the user account to run badvpn-client as.
    net.backend.badvpn(dev, "badvpn", "/usr/bin/badvpn-client", args);

    # Now configure IP on the VPN interface. We just assign an address.
    # DHCP can be used instead for instance.

    # Choose IP address.
    var("10.3.7.62") addr;
    var("24") addr_prefix;

    # Assign IP address.
    net.ipv4.addr(dev, addr, addr_prefix);
}
}}}

= Bus location based configuration =

This example shows how you can configure interfaces based on the bus location (PCI and USB only). It also prints added or removed events for all interfaces, including the bus identifier, so you can easily find the right value for your device. Only the last process is where the interface is actually configured based on bus location. Add more such processes to configure more interfaces.

*NOTE*: you need the latest NCD from the SVN repository; I've only just implemented the `bus` variable of `net.watch_interfaces()`.

{{{
process main {
    # Init process manager.
    process_manager() manager;

    # Allow access to manager.
    provide("GLOBAL");

    # Wait for interface event.
    net.watch_interfaces() watcher;

    println("interface event: ", watcher.event_type, " ", watcher.devname, " ", watcher.bus);

    # Determine event type.
    strcmp(watcher.event_type, "added") is_added;
    strcmp(watcher.event_type, "removed") is_removed;

    # Dispatch.
    provide("interface_event");

    # Handle unknown events.
    ifnot(is_added);
    ifnot(is_removed);
    watcher->nextevent();
}

process interface_event_added {
    # Wait for added event.
    depend("interface_event") dep;
    if(dep.is_added);

    # Get global state.
    depend("GLOBAL") gdep;

    # Start process from template "interface".
    list(dep.watcher.devname, dep.watcher.bus) args;
    gdep.manager->start(dep.watcher.devname, "interface", args);

    # Next event.
    dep.watcher->nextevent();
}

process interface_event_removed {
    # Wait for removed event.
    depend("interface_event") dep;
    if(dep.is_removed);

    # Get global state.
    depend("GLOBAL") gdep;

    # Stop process.
    gdep.manager->stop(dep.watcher.devname);

    # Next event.
    dep.watcher->nextevent();
}

template interface {
    var(_arg0) dev;
    var(_arg1) bus;

    # This template is started and stopped automatically for any
    # interface as it comes and goes.
    # Since we only want to configure predefined interfaces based
    # on bus location, we use provide() communicate with specific
    # processes dealing with those interfaces (like the one just below).

    # Ignore devices with unknown buses.
    strcmp(bus, "unknown") is_unnown;
    ifnot(is_unnown);

    # Build provide name.
    concat("IFACE-BUS-", bus) pname;

    # Provide.
    provide(pname);
}

process interface_1 {
    # Wait for interface by bus.
    depend("IFACE-BUS-pci:0000:06:00.0") busdep;
    var(busdep.dev) dev;

    println("interface_1 starting with name ", dev);
    rprintln("interface_1 stopped with name ", dev);

    # Here comes interface config ... For example:

    # Set device up and wait for link.
    net.up(dev);
    net.backend.waitlink(dev);

    # DHCP configuration.
    # net.ipv4.dhcp() will block here until it obtaines an IP address.
    # Note that it will only obtain the IP address, and *not* assign it;
    # we do that with a separate command below.
    net.ipv4.dhcp(dev) dhcp;

    # Check IP address - make sure it's not local.
    # If you have other reserved subnets around, check for those too.
    ip_in_network(dhcp.addr, "127.0.0.0", "8") test_local;
    ifnot(test_local);

    # Assign IP address, as obtained by DHCP.
    net.ipv4.addr(dev, dhcp.addr, dhcp.prefix);

    # Add default route, as obtained by DHCP.
    net.ipv4.route("0.0.0.0", "0", dhcp.gateway, "20", dev);

    # Configure DNS servers, as obtained by DHCP.
    net.dns(dhcp.dns_servers, "20");

    println("interface_1 up");
    rprintln("interface_1 down");
}

}}}